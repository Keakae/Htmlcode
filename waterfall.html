<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Spectral Waterfall with Microphone</title>
    <style>
        canvas {
            width: 100%;
            height: 300px;
            background-color: #000;
        }
        #status {
            font-size: 20px;
            color: green;
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>WebGPU Spectral Waterfall with Microphone</h1>
    <canvas id="gpuCanvas" width="640" height="480"></canvas>
    <div id="status">Microphone Status: Not working</div>

    <script type="module">
        async function initWebGPU() {
            // Проверка поддержки WebGPU
            if (!navigator.gpu) {
                console.error('WebGPU не поддерживается!');
                return;
            }

            // Получаем адаптер и устройство
            const adapter = await navigator.gpu.requestAdapter();
            const device = await adapter.requestDevice();

            // Настройка канваса и контекста
            const canvas = document.getElementById('gpuCanvas');
            const context = canvas.getContext('webgpu');

            // Настройка формата контекста
            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: format
            });

            // Шейдер для вершин (WGSL)
            const vertexShaderCode = `
            @vertex
            fn main(@builtin(vertex_index) VertexIndex: u32) -> @builtin(position) vec4<f32> {
                var positions = array<vec2<f32>, 4>(
                    vec2<f32>(-1.0, -1.0),
                    vec2<f32>( 1.0, -1.0),
                    vec2<f32>(-1.0,  1.0),
                    vec2<f32>( 1.0,  1.0)
                );
                let pos = positions[VertexIndex];
                return vec4<f32>(pos, 0.0, 1.0);
            }`;

            // Шейдер для фрагментов (WGSL)
            const fragmentShaderCode = `
            @fragment
            fn main(@builtin(position) fragCoord: vec4<f32>) -> @location(0) vec4<f32> {
                let y = fragCoord.y / 480.0;
                return vec4<f32>(y, 0.0, 1.0 - y, 1.0);
            }`;

            // Создание шейдерных модулей
            const vertexModule = device.createShaderModule({ code: vertexShaderCode });
            const fragmentModule = device.createShaderModule({ code: fragmentShaderCode });

            // Создание пайплайна
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: vertexModule,
                    entryPoint: 'main',
                    buffers: []
                },
                fragment: {
                    module: fragmentModule,
                    entryPoint: 'main',
                    targets: [{ format: format }]
                },
                primitive: {
                    topology: 'triangle-strip',
                    cullMode: 'none'
                }
            });

            // Запрос доступа к микрофону
            navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                .then(function(stream) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    const analyser = audioContext.createAnalyser();
                    
                    analyser.fftSize = 2048; // FFT размер
                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);

                    source.connect(analyser);
                    document.getElementById('status').innerHTML = 'Microphone Status: Working';

                    function render() {
                        analyser.getByteFrequencyData(dataArray); // Получаем спектральные данные

                        // Командный энкодер для отрисовки
                        const commandEncoder = device.createCommandEncoder();
                        const textureView = context.getCurrentTexture().createView();

                        // Параметры рендеринга
                        const renderPassDescriptor = {
                            colorAttachments: [{
                                view: textureView,
                                loadOp: 'clear',
                                clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                                storeOp: 'store',
                            }]
                        };

                        // Запуск рендер-прохода
                        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                        passEncoder.setPipeline(pipeline);
                        passEncoder.draw(4, 1, 0, 0); // Рисуем прямоугольник
                        passEncoder.end();

                        // Выполнение команд на GPU
                        device.queue.submit([commandEncoder.finish()]);
                        
                        requestAnimationFrame(render);
                    }

                    render();
                })
                .catch(function(err) {
                    document.getElementById('status').innerHTML = 'Error accessing microphone: ' + err;
                    console.error('Error accessing microphone: ', err);
                });
        }

        // Инициализация WebGPU
        initWebGPU();
    </script>
</body>
</html>
